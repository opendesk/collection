/*
  N.b.: "patch" specs need to be denormalised into indexable data.
  So we have human and api editable JSON which we store as a mix
  of some higher level ORM with JSON values, tbc.
  
  Upstream changes require re-denornalisation of fork data. The
  denormalised data is used for the dimensions hashes.
*/

{
  name: "My Standard Ply",
  description: "I set this up for birch ply. It requires a foobar.",
  /*
    Which product(s) does this target?
    XXX at which version?
  */
  products: [
    "lean/desk/standard",
    "lean/desk/foo"
  ],
  /*
    ***Product*** Versioning
    XXX see `Versioning.md`

    -> dist is published against the latest version, storing the product commit
    hash in `product_versions`
    -> when the product is changed (new commit) get all the dists that matched
    the old version
    -> if the aspect-dimension hash is the same
    -> then add the new product commit hash to the versions list

    -> if there's a demand event for a product version that doesn't have a dist
    -> it's envisaged the UI would indicate to designer/production that there
    was a dist that matched the last/a previous version
    -> if they choose to they could say "ah, that old dist is fine"
    -> at which point we add the new commit hash to the product versions

    -> if the dimension hash had changed
    -> the UI should indicate what in it changed, i.e.: a diff against the
    dimension data
    -> which helps the manual decision process

  */
  product_versions: [
    "${MAJOR_VERSION}:cc7a168c39016f4e5b03dcbc1c85e5de48bc70c2",
    "${MAJOR_VERSION}:16f4e5b03dcbc1c85e5de48bc70c2cc7a168c390"
  ],
  /*
    ***Distribution*** Versioning.
    XXX works exactly as per our current dist versioning.
    XXX this needs a dropbox + commit message UI.
  */
  version: {
    major: 1,
    minor: 0,
    rev: 0
  },
  /*
    XXX dist files
    XXX back up the s3 bucket!
  */ 
  files: [],
  /*
    Now it's about either just not narrowing down, or specifying something
    that's more specific than the product spec. UI expects certain things
    based on the product configuration, i.e.: the product says it's one
    of these, so which one is it -> either carry through the high level
    spec or narrow it down.
  */
  /*
    Step 1: optionally make the unit specifications more specific.
  */
  materials: [
    {
      id: "birch-ply",
      requires: {
        sheet_size: {
          width: 1200,
          length: 1800
        },
        thickness: [17.5, 18.5]
      }
    }
  ],
  processes: [
    {
      id: "machining",
      requires: {
        bit_size: [null, 6]
      }
    }
  ],
  /*
    Say which one(s) you support.
  */
  choices: {
    sizes: ["medium"],
    config: {
      "cable-tray": ["open"],
      "desktop-shape": ["default"]
    }
    materials: ["birch-faced-plywood:all-birch"],
    // e.g.: if needed processes: ["birch-ply:sanded-twice"],
  }
}